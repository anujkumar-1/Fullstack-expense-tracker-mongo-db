import { instantiate } from './wasm/arcjet_analyze_js_req.component.js';
import { wasm } from './_virtual/arcjet_analyze_js_req.component.core.js';
import { wasm as wasm$1 } from './_virtual/arcjet_analyze_js_req.component.core2.js';
import { wasm as wasm$2 } from './_virtual/arcjet_analyze_js_req.component.core3.js';

const FREE_EMAIL_PROVIDERS = [
    "gmail.com",
    "yahoo.com",
    "hotmail.com",
    "aol.com",
    "hotmail.co.uk",
];
// TODO: Do we actually need this wasmCache or does `import` cache correctly?
const wasmCache = new Map();
async function moduleFromPath(path) {
    const cachedModule = wasmCache.get(path);
    if (typeof cachedModule !== "undefined") {
        return cachedModule;
    }
    if (path === "arcjet_analyze_js_req.component.core.wasm") {
        const mod = await wasm();
        wasmCache.set(path, mod);
        return mod;
    }
    if (path === "arcjet_analyze_js_req.component.core2.wasm") {
        const mod = await wasm$1();
        wasmCache.set(path, mod);
        return mod;
    }
    if (path === "arcjet_analyze_js_req.component.core3.wasm") {
        const mod = await wasm$2();
        wasmCache.set(path, mod);
        return mod;
    }
    throw new Error(`Unknown path: ${path}`);
}
function noOpDetect() {
    return [];
}
async function init(context, detectSensitiveInfo) {
    const { log } = context;
    if (typeof detectSensitiveInfo !== "function") {
        detectSensitiveInfo = noOpDetect;
    }
    const coreImports = {
        "arcjet:js-req/email-validator-overrides": {
            isFreeEmail(domain) {
                if (FREE_EMAIL_PROVIDERS.includes(domain)) {
                    return "yes";
                }
                return "unknown";
            },
            isDisposableEmail() {
                return "unknown";
            },
            hasMxRecords() {
                return "unknown";
            },
            hasGravatar() {
                return "unknown";
            },
        },
        "arcjet:js-req/sensitive-information-identifier": {
            detect: detectSensitiveInfo,
        },
        "arcjet:js-req/verify-bot": {
            verify() {
                return "unverifiable";
            },
        },
    };
    try {
        // Await the instantiation to catch the failure
        return await instantiate(moduleFromPath, coreImports);
    }
    catch {
        log.debug("WebAssembly is not supported in this runtime");
    }
}
/**
 * Generate a fingerprint for the client. This is used to identify the client
 * across multiple requests.
 * @param context - The Arcjet Analyze context.
 * @param request - The request to fingerprint.
 * @returns A SHA-256 string fingerprint.
 */
async function generateFingerprint(context, request) {
    const analyze = await init(context);
    if (typeof analyze !== "undefined") {
        return analyze.generateFingerprint(JSON.stringify(request), context.characteristics);
    }
    return "";
}
async function isValidEmail(context, candidate, options) {
    const analyze = await init(context);
    const optionsOrDefault = {
        requireTopLevelDomain: true,
        allowDomainLiteral: false,
        blockedEmails: [],
        ...options,
    };
    if (typeof analyze !== "undefined") {
        return analyze.isValidEmail(candidate, optionsOrDefault);
    }
    else {
        // Skip the local evaluation of the rule if WASM is not available
        return {
            validity: "valid",
            blocked: [],
        };
    }
}
async function detectBot(context, request, options) {
    const analyze = await init(context);
    if (typeof analyze !== "undefined") {
        return analyze.detectBot(JSON.stringify(request), options);
    }
    else {
        // Skip the local evaluation of the rule if Wasm is not available
        return {
            allowed: [],
            denied: [],
            spoofed: false,
            verified: false,
        };
    }
}
async function detectSensitiveInfo(context, candidate, entities, contextWindowSize, detect) {
    const analyze = await init(context, detect);
    if (typeof analyze !== "undefined") {
        const skipCustomDetect = typeof detect !== "function";
        return analyze.detectSensitiveInfo(candidate, {
            entities,
            contextWindowSize,
            skipCustomDetect,
        });
    }
    else {
        throw new Error("SENSITIVE_INFO rule failed to run because Wasm is not supported in this environment.");
    }
}

export { detectBot, detectSensitiveInfo, generateFingerprint, isValidEmail };
